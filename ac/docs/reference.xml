<?xml version="1.0" encoding="utf-8"?>
<!-- default transformation -->
<!--<?xml-stylesheet type="text/xsl" href="transformations/cuberef2cubescript.xslt"?>-->
<?xml-stylesheet type="text/xsl" href="transformations/cuberef2xhtml.xslt"?>

<!--
  See reference.xsd and types.xsd before editing this file.
-->

<cuberef name="AssaultCube Reference" version="v1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://cubers.net/Schemas/CubeRef schemas/cuberef.xsd" xmlns="http://cubers.net/Schemas/CubeRef">
  <description>
    This reference describes the commands and variables available in AssaultCube.
  </description>
  <sections sort="true">
    <section name="CubeScript" sortindex="0">
      <description>This section describes identifiers that are closely related to the CubeScript language.</description>
      <identifiers sort="true">
        <command name="+">
          <description>Performs an addition.</description>
          <remarks>
            <remark>
              Example: echo the sum of x and y is (+ $x $y)
            </remark>
          </remarks>
          <arguments>
            <argument token="A" description="the first summand"/>
            <argument token="B" description="the second summand"/>
          </arguments>
          <return token="N" description="the sum"/>
        </command>
        <command name="-">
          <description>Performs a subtraction.</description>
          <arguments>
            <argument token="A" description="the minuend"/>
            <argument token="B" description="the subtrahend"/>
          </arguments>
          <return token="N" description="the difference"/>
        </command>
        <command name="*">
          <description>Performs a multiplication.</description>
          <arguments>
            <argument token="A" description="the multiplicand"/>
            <argument token="B" description="the multiplier"/>
          </arguments>
          <return token="N" description="the product"/>
        </command>
        <command name="div">
          <description>Performs a division.</description>
          <arguments>
            <argument token="A" description="the dividend"/>
            <argument token="B" description="the divisor"/>
          </arguments>
          <return token="N" description="the quotient"/>
        </command>
        <command name="mod">
          <description>Performs a modulo operation.</description>
          <arguments>
            <argument token="A" description="the dividend"/>
            <argument token="B" description="the divisor"/>
          </arguments>
          <return token="N" description="the modulo value"/>
        </command>
        <command name="=">
          <description>Determines if two values are equal.</description>
          <arguments>
            <argument token="A" description="first value"/>
            <argument token="B" description="second value"/>
          </arguments>
          <return token="N" description="the equality" valueNotes="1 (equal) or 0 (unequal)"/>
        </command>
        <command name="&lt;">
          <description>Determines if a value is smaller than a second value.</description>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
          <return token="N" description="the comparison" valueNotes="1 (smaller) or 0 (not smaller)"/>
        </command>
        <command name="&gt;">
          <description>Determines if a value is bigger than a second value.</description>
          <arguments>
            <argument token="A" description="the first value"/>
            <argument token="B" description="the second value"/>
          </arguments>
          <return token="N" description="the comparison" valueNotes="1 (bigger) or 0 (not bigger)"/>
        </command>
        <command name="rnd">
          <description>Random value</description>
          <arguments>
            <argument token="A" description="The upper limit of the random value" valueNotes="" />
          </arguments>
          <return token="R" description="The random value" valueNotes="larger or equal 0 and smaller than A"/>
        </command>
        <command name="strcmp">
          <description>Determines if two strings are equal.</description>
          <arguments>
            <argument token="A" description="the first string"/>
            <argument token="B" description="the second string"/>
          </arguments>
          <return token="N" description="the equality" valueNotes="1 (equal) or 0 (unequal)"/>
        </command>
        <command name="if">
          <description>Controls the script flow based on a boolean expression.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                  if (> $x 10) [ echo x is bigger than 10 ] [ echo x too small ]
                ]]>
              </code>
            </example>
          </examples>
          <arguments>
            <argument token="cond" description="the condition" valueNotes="0 (false) or anything else (true)"/>
            <argument token="true" description="the body to execute if the condition is true"/>
            <argument token="false" description="the body to execute if the condition is true"/>
          </arguments>
        </command>
        <command name="loop">
          <description>Loops the specified body.</description>
          <remarks>
            <remark>
              This command sets the alias you choose, as first argument, from 0 to N-1 for every iteration.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>
                <![CDATA[
                  loop i 10 [ echo $i ]
                ]]>
              </code>
            </example>
          </examples>
          <arguments>
            <argument token="V" description="the alias used as counter"/>
            <argument token="N" description="the amount of loops"/>
            <argument token="body" description="the body to execute on each iteration"/>
          </arguments>
        </command>
        <command name="while">
          <description>Loops the specified body while the condition evaluates to true.</description>
          <remarks>
            <remark>
              This command sets the alias "i" from 0 to N-1 for every iteration.
              Note that the condition here has to have [], otherwise it would only be evaluated once.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>
                <![CDATA[
                  alias i 0; while [ (< $i 10) ] [ echo $i; alias i (+ $i 1) ]
                ]]>
              </code>
            </example>
          </examples>
          <arguments>
            <argument token="cond" description="the condition" valueNotes="0 (false) or anything else (true)"/>
            <argument token="body" description="the body to execute on each iteration"/>
          </arguments>
        </command>
        <command name="concat">
          <description>Concatenates multiple strings with spaces inbetween.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                  alias a "hello"; echo (concat $a "world")
                ]]>
              </code>
              <explanation>
                output: hello world
              </explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the first string"/>
            <variableArgument token="..." description="collection of strings to concatenate"/>
          </arguments>
          <return token="R" description="The newly created string"/>
        </command>
        <command name="concatword">
          <description>Concatenates multiple strings.</description>
          <remarks>
            <remark>
              The newly created string is saved to the alias 's'.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>
                <![CDATA[
                  alias a "Cube"; echo (concatword $a "Script")
                ]]>
              </code>
              <explanation>
                output: CubeScript
              </explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the first string"/>
            <variableArgument token="..." description="collection of strings to concatenate"/>
          </arguments>
          <return token="R" description="The newly created string"/>
        </command>
        <command name="at">
          <description>Grabs a word out of a string.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                  echo (at "zero one two three" 2)
                ]]>
              </code>
              <explanation>
                output: two
              </explanation>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the string"/>
            <argument token="N" description="the index of the word"/>
          </arguments>
          <return token="W" description="the word from the specified idex"/>
        </command>
        <command name="findlist">
          <description>Searches a list for a specified value.</description>
          <arguments>
            <argument token="L" description="the list"/>
            <argument token="I" description="the item to find"/>
          </arguments>
          <return token="I" description="the index of the item in the list"/>
        </command>
        <command name="sleep">
          <description>Executes a command after specified time period.</description>
          <examples>
            <example>
              <code>
                <![CDATA[
                  sleep 1000 [ echo foo ]
                ]]>
              </code>
              <explanation>
                Prints 'foo' to the screen after 1 second.
              </explanation>
            </example>
          </examples>
          <arguments>
            <argument token="N" description="the amount of milliseconds"/>
            <argument token="C" description="the command to execute"/>
          </arguments>
        </command>
        <variable name="numargs">
          <description>The number of arguments passed to the current alias</description>
          <value token="V" description="numargs" minValue="0" maxValue="25" defaultValue="0" readOnly="true"/>
        </variable>        
      </identifiers>    
    </section>
    <section name="General" sortindex="1">
      <description>
        This section describes general identifiers.
      </description>
      <identifiers sort="true">
        <variable name="autogetmap">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <command name="callvote">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <variable name="clockerror">
          <value token="V" description="" minValue="990000" maxValue="1010000" defaultValue="1000000" />
        </variable>
        <variable name="clockfix">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="dbgts">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="maxfps">
          <value token="V" description="" minValue="0" maxValue="500" defaultValue="200" />
        </variable>
        <variable name="maxrecoil">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="1000" />
        </variable>
        <variable name="maxtmus">
          <value token="V" description="" minValue="1" maxValue="0" defaultValue="0" />
        </variable>
        <variable name="minlod">
          <value token="V" description="" minValue="LOW_LOD" maxValue="MAX_LOD" defaultValue="60" />
        </variable>
        <variable name="modeacronyms">
          <description>Turns on/off use of acronyms instead of full modenames in the serverbrowser.</description>
          <value token="B" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="resetcfg">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="searchlan">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <command name="setmaster">
          <description>Claims or drops master status.</description>
          <remarks>
            <remark>
              Claiming master status is only possible if no other player is already master.
              In the scoreboard, the master is marked green.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setadmin"/>
            <identifierReference identifier="kick"/>
            <identifierReference identifier="autoteam"/>
            <identifierReference identifier="mastermode"/>
          </references>
          <arguments>
            <argument token="B" description="status" valueNotes="1 (claim), 0 (drop)"/>
          </arguments>
        </command>
        <command name="setadmin">
          <description>Claims or drops admin status.</description>
          <remarks>
            <remark>
              Successfully claiming admin status revokes other players master or admin state automatically.
              Failed logins result in an auto kick.
              The admin is granted the right to kick, ban, remove bans, set autoteam and change the mastermode.
              In the scoreboard, the admin is marked red.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="kick"/>
            <identifierReference identifier="autoteam"/>
            <identifierReference identifier="mastermode"/>
            <identifierReference identifier="ban"/>
            <identifierReference identifier="removebans"/>
          </references>
          <arguments>
            <argument token="B" description="status" valueNotes="1 (claim), 0 (drop)"/>
            <argument token="P" description="password" valueNotes="max. 15 characters"/>
          </arguments>
        </command>
        <variable name="smoothdist">
          <value token="V" description="" minValue="0" maxValue="16" defaultValue="8" />
        </variable>
        <variable name="smoothmove">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="75" />
        </variable>
        <variable name="throttle_accel">
          <value token="V" description="" minValue="0" maxValue="32" defaultValue="2" />
        </variable>
        <variable name="throttle_decel">
          <value token="V" description="" minValue="0" maxValue="32" defaultValue="2" />
        </variable>
        <variable name="throttle_interval">
          <value token="V" description="" minValue="0" maxValue="30" defaultValue="5" />
        </variable>
        <command name="toggleconsole">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <command name="kick">
          <description>Kicks a specified player from the server.</description>
          <remarks>
            <remark>Requires master or admin state.</remark>
          </remarks>
          <references>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="N" description="the player to kick" valueNotes="client number"/>
          </arguments>
        </command>
        <variable name="tsswap">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="version">
          <value token="V" description="" minValue="1" maxValue="0" defaultValue="AC_VERSION" />
        </variable>
        <command name="ban">
          <description>Bans a specified player from the server.</description>
          <remarks>
            <remark>
              Requires master or admin state. The ban duration is fixed to 20 minutes.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="removebans"/>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="N" description="the player to ban" valueNotes="client number"/>
          </arguments>
        </command>
        <command name="removebans">
          <description>Removes all bans on the server.</description>
          <remarks>
            <remark>
              Requires master or admin state.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="ban"/>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
        </command>
        <command name="autoteam">
          <description>Sets the automated team assignement.</description>
          <remarks>
            <remark>
              Requires master or admin state.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="B" description="enables or disables auto team" valueNotes="1 (on), 0 (off)"/>
          </arguments>
        </command>
        <command name="mastermode">
          <description>Sets the mastermode for the server.</description>
          <remarks>
            <remark>
              Requires master or admin state. If the mastermode is set to 'private', no more clients can join the server.
              Default is 'open' that allows anyone to join the server.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="N" description="the master mode" valueNotes="0 (open), 1 (private)"/>
          </arguments>
        </command>
        <command name="forceteam">
          <description>Forces a specified player to join the enemy team.</description>
          <remarks>
            <remark>
              Requires master or admin state.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="N" description="the player to assign to a team" valueNotes="client number"/>
          </arguments>
        </command>
        <command name="giveadmin">
          <description>Gives the admin state to the specified player.</description>
          <remarks>
            <remark>
              Requires admin state. The admin will lose his admin state after successfully issuing this command.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="setmaster"/>
            <identifierReference identifier="setadmin"/>
          </references>
          <arguments>
            <argument token="N" description="the player to become master" valueNotes="client number"/>
          </arguments>
        </command>
        <command name="map">
          <description>Loads up a map in the gamemode set previously by the 'mode' command.</description>
          <remarks>
            <remark>
              If connected to a multiplayer server, votes to load this map (others will have to type "map M" as well to agree with loading this map). To vote for a map with a specific mode, set the mode before you issue the map command (see multiplayer menu).
            </remark>
            <remark>
              A map given as "blah" refers to "packages/base/blah.cgz", "mypackage/blah" refers to "packages/mypackage/blah.cgz".
              At every map load, "config/default_map_settings.cfg" is loaded which sets up all texture definitions, etc. Everything
              defined in there can be overridden per package or per map by creating a "package.cfg" or "mapname.cfg" which
              contains whatever you want to do differently from the default.
            </remark>
            <remark>
              When the map finishes it will load the next map when one is defined, otherwise reloads the current map.
              You can define what map follows a particular map by making an alias like (in the map script): alias nextmap_blah1 blah2
              (loads "blah2" after "blah1").
            </remark>
            <remark>
              TODO: multiplayer voting
            </remark>
          </remarks>
          <arguments>
            <argument token="M" description="name of the map to load" valueNotes="string"/>
          </arguments>
        </command>
        <command name="jump">
          <description>Triggers a jump.</description>
          <remarks>
            <remark>default keys: space and right mouse.</remark>
          </remarks>
        </command>
        <command name="updatefrommaster">
          <description>Contacts the masterserver and adds any new servers to the server list.</description>
          <remarks>
            <remark>The servers are written to the config/servers.cfg file. This menu can be reached through the Multiplayer menu.</remark>
          </remarks>
        </command>
        <command name="millis">
          <description>Returns the number of milliseconds since engine start.</description>
          <examples>
            <example>
              <code>echo (millis)</code>
            </example>
          </examples>
          <return token="N" description="the milliseconds"/>
        </command>
        <command name="bind">
          <description>Binds a key to a command.</description>
          <remarks>
            <remark>
              To find out what key names and their default bindings are, look at config/keymap.cfg,
              then add bind commands to your autoexec.cfg.
            </remark>
          </remarks>
          <arguments>
            <argument token="K" description="the key to bind" valueNotes="string"/>
            <argument token="A" description="the command" valueNotes="string, usually an alias"/>
          </arguments>
        </command>
        <command name="onrelease">
          <description>Executes a command on the release of a key/button.</description>
          <remarks>
            <remark>
              This command must be placed in an action in a bind or in an alias in a bind.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>bind CTRL [ echo "key pressed"; onrelease [ echo "key released" ] ]</code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="bind"/>
          </references>
          <arguments>
            <argument token="A" description="the command"/>
          </arguments>
        </command>
        <command name="alias">
          <description>Binds a name to commands.</description>
          <remarks>
            <remark>
              It is possible to re-bind an alias, even during its evaluation.
            </remark>
            <remark>
              Example: alias myalias [ echo "hello world"; alias myalias [ echo "I already said hello" ] ]
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of the alias" valueNotes="string, must not contain '$'"/>
            <argument token="A" description="the commands" valueNotes="string"/>
          </arguments>
        </command>
        <command name="quit">
          <description>Quits the game without asking.</description>
        </command>
        <command name="forward">
          <description>Moves the player forward.</description>
          <remarks>
            <remark>default keys: W and Up Arrow</remark>
          </remarks>
        </command>
        <command name="backward">
          <description>Moves the player backward.</description>
          <remarks>
            <remark>default keys: S and Down Arrow</remark>
          </remarks>
        </command>
        <command name="left">
          <description>Moves the player left.</description>
          <remarks>
            <remark>default keys: A and Left Arrow</remark>
          </remarks>
        </command>
        <command name="right">
          <description>Moves the player right.</description>
          <remarks>
            <remark>default keys: D and Right Arrow</remark>
          </remarks>
        </command>
        <command name="attack">
          <description>Fires the current weapon.</description>
          <remarks>
            <remark>default: left mouse button</remark>
          </remarks>
        </command>
        <command name="invmouse">
          <description>Sets mouse to "flight sim" mode.</description>
          <arguments>
            <argument token="B" description="sets invmouse" valueNotes="0 (off), else (on)"/>
          </arguments>
        </command>
        <command name="minmillis">
          <description>Sets the minimum number of milliseconds a frame should take.</description>
          <remarks>
            <remark>
              This is for very fast machines that run Cube at hundreds of fps.
              Default is 5, i.e. try to stay close to 200fps.
              This command is not exact, i.e. the precise delay it generates depends on OS and other factors...
              experiment with your ideal setting.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the number of milliseconds" valueNotes="integer, 0 (off), default is 5"/>
          </arguments>
        </command>
        <command name="screenshot">
          <description>Takes a screenshot.</description>
          <remarks>
            <remark>
              Screenshots are saved to "screenshots/screenshotN.bmp",
              where N is the number of milliseconds since the game was launched.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="F12"/>
          </defaultKeys>
        </command>
        <command name="exec">
          <description>Executes all commands in a specified config file.</description>
          <arguments>
            <argument token="C" description="the config file"/>
          </arguments>
        </command>
        <command name="keymap">
          <description>Sets up the keymap for the specified key.</description>
          <remarks>
            <remark>
              You should never have to use this command manually, use "bind" instead.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="bind"/>
          </references>
          <arguments>
            <argument token="K" description="the key to map"/>
            <argument token="N" description="the name for the key"/>
            <argument token="A" description="the default action"/>
          </arguments>
        </command>
        <command name="sensitivity">
          <description>Sets the mouse sensitivity.</description>
          <remarks>
            <remark>
              With 'sensitivityscale' you can specify a number that the sensitivity is divided by.
            </remark>
          </remarks>
          <references>
            <identifierReference name="sensitivityscale" identifier="sensitivityscale"/>
          </references>
          <arguments>
            <argument token="S" description="the sensitivity" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="addserver">
          <description>Adds a server to the list of server to query in the server list menu.</description>
          <arguments>
            <argument token="S" description="the name of the server (cn/ip)"/>
            <argument token="P" description="the port"/>
          </arguments>
        </command>
        <command name="clearsecuremaps">
          <description>Clears the list of secured maps.</description>
          <references>
            <identifierReference identifier="securemap"/>
          </references>
        </command>
        <command name="securemap">
          <description>Adds a map to the list of secured maps.</description>
          <remarks>
            <remark>
              Secured maps can not be overwritten by the commands sendmap and getmap.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="clearsecuremaps"/>
            <identifierReference identifier="sendmap"/>
            <identifierReference identifier="getmap"/>
          </references>
          <arguments>
            <argument token="S" description="the name of the map"/>
          </arguments>
        </command>
        <variable name="gamemode">
          <description>Holds the current game mode.</description>
          <value description="gamemode" minValue="1" maxValue="0" defaultValue="0"/>
        </variable>
        <variable name="connected">
          <description>Indicates if a connection to a server exists.</description>
          <value token="B" description="the connection state" valueNotes="1 (connected), 0 (disconnected)" minValue="0" maxValue="1" defaultValue="0"/>
        </variable>
        <variable name="maxroll">
          <description>Sets the maximum value the display will roll on strafing.</description>
          <value token="N" description="the roll value" minValue="0" maxValue="20" defaultValue="0"/>
        </variable>
        <variable name="rate">
          <description>Sets the clients maximum downstream bandwidth.</description>
          <remarks>
            <remark>
              Leaving it at 0 (the default) means the server will dynamically try to do the best thing,
              this is recommended for players who don't have a clue what their bandwidth is
              (setting your rate unoptimally is worse than not setting it all).
              Modem players (56k) could try rate 4000 and tweak from there, dsl players can try rate 6000-10000.
              Note that the more players on a server, the more critical the effect of your rate.
              If you are tweak addicted, you can try playing with the variables throttle_decel
              (how quickly to start dropping packets when your connection becomes bandwidth limited)
              throttle_accel (how quickly to recover once bandwidth becomes available again) and
              throttle_interval (how quickly to reestimate the situation). Change the defaults at your own risk.
            </remark>
          </remarks>
          <value token="N" description="the bytes per second" minValue="0" maxValue="25000" defaultValue="0"/>
        </variable>
      </identifiers>
    </section>
    <section name="Gameplay" sortindex="3">
      <description>
        This section describes gameplay related identifiers.
      </description>
      <identifiers>
        <command name="alive">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <variable name="minutesremaining">
          <value token="V" description="" minValue="1" maxValue="0" defaultValue="0" />
        </variable>
        <command name="nextprimary">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <variable name="paused">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <command name="reload">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <variable name="autoreload">
          <description>Indicates if the weapons should be reloaded automatically.</description>
          <value token="B" description="the autoreload state" minValue="0" maxValue="1" defaultValue="1" valueNotes="on (1), off (0)"/>
        </variable>        
        <variable name="scopefov">
          <value token="V" description="" minValue="5" maxValue="50" defaultValue="50" />
        </variable>
        <variable name="showmap">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="showscoresondeath">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <command name="skin">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <command name="name">
          <description>Sets the nick name for the local player.</description>
          <arguments>
            <argument token="N" description="the name"/>
          </arguments>
        </command>
        <command name="say">
          <description>Outputs text to other players.</description>
          <remarks>
            <remark>
              If the text begins with an percent character (%),
              only team mates will receive the message.
            </remark>
          </remarks>
          <arguments>
            <variableArgument token="S..." description="the text"/>
          </arguments>
        </command>
        <variable name="xhairwpsel">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <command name="saycommand">
          <description>
            Puts a prompt on screen.
          </description>
          <remarks>
            <remark>
              this puts a prompt on screen where you can type stuff into,
              which will capture all keystrokes until you press return (or esc to cancel).
              If what you typed started with a "/", the rest of it will be executed as a command,
              otherwise its something you "say" to all players.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="T" description="opens empty prompt"/>
            <key alias="BACKQUOTE" name="`" description="opens a command prompt /"/>
            <key alias="TAB" description="autocompletes commands/variables/aliases"/>
            <key alias="UP" description="browse command history forwards"/>
            <key alias="DOWN" description="browse command history backwards"/>
          </defaultKeys>
          <arguments>
            <variableArgument token="S..." description="the text to display in the prompt" optional="true"/>
          </arguments>
        </command>
        <command name="connect">
          <description>
            Connects to a server.
          </description>
          <remarks>
            <remark>
              If the server name ist omitted, the client will try to connect to an available server in the LAN.
              If the port is omitted or set to 0, the default port will be used.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>
                connect 127.0.0.1 555 myServerPassword
              </code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="connectadmin"/>
          </references>
          <arguments>
            <argument token="N" description="the (dns) name or ip of the server" optional="true"/>
            <argument token="O" description="the port" optional="true"/>
            <argument token="P" description="the server password" optional="true"/>
          </arguments>
        </command>
        <command name="connectadmin">
          <description>Connects to a server and tries to claim admin state.</description>
          <remarks>
            <remark>
              This command will connect to a server just like the command 'connect' and
              try to claim admin state. If the specified password is correct, the admin
              will be able to connect even if he is locked out by ban, private master mode or taken client slots.
              If successfully connected, bans assigned to the admin's host will be removed automatically. If all
              client slots are taken a random client will be kicked to let the admin in.
            </remark>
            <remark>
              If the server name ist omitted, the client will try to connect to an available server in the LAN.
              If the port is omitted or set to 0, the default port will be used.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>
                connectadmin 127.0.0.1 777 myAdminPassword
              </code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="connect"/>
          </references>
          <arguments>
            <argument token="N" description="the (dns) name or ip of the server"/>
            <argument token="O" description="the port" optional="true"/>
            <argument token="P" description="the admin password"/>
          </arguments>
        </command>
        <command name="disconnect">
          <description>Leaves a server.</description>
        </command>
        <command name="followmode">
          <description>
            Choose the mode of following. Either "chase" [3rd person] or "embody" [1st person].
          </description>
          <arguments>
            <argument token="N" description="followmode" valueNotes="0 (chase) or 1 (embody)" default="1"/>
          </arguments>
          <defaultKeys>
            <key alias="F6" description="toggle between chase and embody followmode"/>
          </defaultKeys>
        </command>
        <command name="team">
          <description>Sets the team for the local player.</description>
          <examples>
            <example>
              <code>
                team CLA
              </code>
            </example>
          </examples>
          <arguments>
            <argument token="S" description="the team name" valueNotes="either CLA or RVSF"/>
          </arguments>
        </command>
        <command name="showscores">
          <description>Shows or hides the scores.</description>
          <defaultKeys>
            <key alias="TAB"/>
          </defaultKeys>
        </command>
        <command name="weapon">
          <description>Changes the weapon.</description>
          <arguments>
            <argument token="N" description="the weapon number" valueNotes="0 (knife), 1 (pistol), 2 (shotgun), 3 (sub), 4 (sniper), 5 (assault), 6 (grenades)"/>
          </arguments>
        </command>
        <command name="magcontent">
          <description>Returns contents of current magazine.</description>
          <arguments>
            <argument token="N" description="the weapon number" valueNotes="0 (knife), 1 (pistol), 2 (shotgun), 3 (sub), 4 (sniper), 5 (assault), 6 (grenades)"/>
          </arguments>
        </command>
        <command name="magreserve">
          <description>Returns contents of magazine reserve.</description>
          <arguments>
            <argument token="N" description="the weapon number" valueNotes="0 (knife), 1 (pistol), 2 (shotgun), 3 (sub), 4 (sniper), 5 (assault), 6 (grenades)"/>
          </arguments>
        </command>
        <command name="mode">
          <description>Set gameplay mode to N for the next game played (next map load).</description>
          <references>
            <identifierReference identifier="map"/>
          </references>
          <arguments>
            <argument token="N" description="the mode number" valueNotes="TODO"/>
          </arguments>
        </command>
        <command name="sendmap">
          <description>Sends the current map to the server and sends other players a message about it.</description>
          <remarks>
            <remark>
              If the map argument is specified, the map is first saved and then reloaded before sending it.
              Note its always required to be on the map one wants
              to send before issuing this command!
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="getmap"/>
          </references>
          <arguments>
            <argument token="M" description="map to save and reload locally" optional="true"/>
          </arguments>
        </command>
        <command name="getmap">
          <description>Retrieves the last map that was sent to the server using 'sendmap'.</description>
          <references>
            <identifierReference identifier="sendmap"/>
          </references>
        </command>
        <command name="spectate">
          <description>
            Toggle into spectator mode - only possible when you're dead!
          </description>
          <defaultKeys>
            <key alias="F7" description="free-flying spectator"/>
            <key alias="F8" description="follow spectator (see followmode)"/>
          </defaultKeys>
        </command>
        <command name="stopdemo">
          <description>
            Stops any demo recording or playback.
          </description>
        </command>
        <command name="suicide">
          <description>
            Kill yourself.
          </description>
        </command>
        <command name="demo">
          <description>Plays a recorded demo.</description>
          <remarks>
            <remark>
              Playback is interpolated for the player whose perspective you view.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="the demo name"/>
          </arguments>
        </command>
        <command name="demoplayer">
          <description>Shifts the camera to an other demo player</description>
          <arguments>
            <argument token="N" description="the shift direction" valueNotes="1 (forwards), -1 (backwards)"/>
          </arguments>
        </command>
        <variable name="footsteps">
          <description>Indicates if the footsteps sound should be played</description>
          <value token="B" description="enable footsteps" minValue="0" maxValue="1" defaultValue="1" valueNotes="1 (true), 0 (false)"/>
        </variable>
        <variable name="footstepalign">
          <description>Maximum time span between player animation and the playback of the footstep sound</description>
          <remarks>
            <remark>
              If the footstep sound would be played immediately when entering the radius of the other player, it would
              not be synchronous to the player model animation.
            </remark>
          </remarks>
          <value token="T" description="time span" minValue="5" maxValue="4000" defaultValue="15"/>
        </variable>
        <variable name="demoplaybackspeed">
          <description>Sets the playback speed for a demo.</description>
          <remarks>
            <remark>To see the effect, the variable must be set before playing a demo.</remark>
          </remarks>
          <value token="P" description="the playback speed" minValue="10" maxValue="1000" defaultValue="100"/>
        </variable>
        <variable name="gamespeed">
          <description>Sets the gamespeed in percent.</description>
          <remarks>
            <remark>This does not work in multiplayer. For entertainment purposes only :)</remark>
          </remarks>
          <value token="N" description="the game speed" minValue="10" maxValue="1000" defaultValue="100"/>
        </variable>
      </identifiers>
    </section>
    <section name="Editing" sortindex="2">
      <identifiers>
        <variable name="lightscale">
          <description>Used to finetune the "overbright lighting" rendering feature when enabled.</description>
          <remarks>
            <remark>
              After changing this value, a "recalc" is needed to see the differences.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="recalc"/>
          </references>
          <value token="N" description="the brightness of the scene" minValue="1" maxValue="100" defaultValue="4"/>
        </variable>
        <command name="fogcolour">
          <description>Sets fog and clearing colour.</description>
          <remarks>
            <remark>This and the fog variable can be set in the map config file.</remark>
          </remarks>
          <arguments>
            <argument token="C" description="the colour" valueNotes="integer, default is 0x8099B3"/>
          </arguments>
        </command>
        <command name="fog">
          <description>Sets the fog distance.</description>
          <remarks>
            <remark>
              You can do this for tweaking the visual effect of the fog, or if you are on a slow machine,
              setting the fog to a low value can also be a very effective way to increase fps (if you are geometry limited).
              Try out different values on big maps / maps which give you low fps.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the fog distance" valueNotes="integer, default is 160"/>
          </arguments>
        </command>
        <command name="edittoggle">
          <description><![CDATA[switches between map edit mode and normal.]]></description>
          <remarks>
            <remark>
              In map edit mode you can select bits of the map by clicking or dragging your crosshair on the floor
              or ceiling (using the "attack" identifier, normally MOUSE1), then use the identifiers below to
              modify the selection. While in edit mode, physics and collision don't apply (noclip), and key repeat is ON.
              Note that if you fly outside the map, cube still renders the world as if you were standing on the floor
              directly below the camera.
            </remark>
            <remark>
              Hotkey E
            </remark>
          </remarks>
          <references>
            <identifierReference name="select" identifier="select"/>
            <webReference name="The Editing Mode" url="http://wiki.cubers.net/wiki/EditingMode"/>
          </references>
        </command>
        <command name="watercolour">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <command name="edittex">
          <description><![CDATA[Changes the texture on current selection by browsing through a list of textures directly shown on the cubes. ]]></description>
          <remarks>
            <remark>
              Default keys are the six keys above the cursor keys, which each 2 of them cycle one type (and numpad 7/4 for upper).
            </remark>
            <remark>
              The way this works is slightly strange at first, but allows for very fast texture assignment. All textures are in 3 individual lists for each type (both wall kinds treated the same), and each time a texture is used, it is moved to the top of the list. So after a bit of editing, all your most frequently used textures will come first when pressing these keys, and the most recently used texture is set immediately when you press the forward key for the type. These lists are saved with the map. make a selection (including wall bits) and press these keys to get a feel for what they do.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 1 (lower or wall), 2 (ceiling), 3 (upper wall)" />
            <argument token="D" description="the direction you want to cycle the textures in" valueNotes="1 (forwards), -1 (backwards)" />
          </arguments>
        </command>
        <command name="editheight">
          <description><![CDATA[Changes the height of the current selection.]]></description>
          <remarks>
            <remark>
              Default keys are [ and ] for floor level, and o/p for ceiling.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 2 (ceiling)" />
            <argument token="D" description="the delta value to move it in" valueNotes="1 (forwards), -1 (backwards)" />
          </arguments>
        </command>
        <command name="solid">
          <description>makes the current selection all solid (i.e. wall) or all non-solid.</description>
          <remarks>
            <remark>
              This operation retains floor/ceiling heights/textures while swapping between the two. Default keys f and g respectively.
            </remark>
          </remarks>
          <arguments>
            <argument token="B" description="an integer denoting the solid-ness" valueNotes="0 (non-solid), 1..* (solid)" />
          </arguments>
        </command>
        <command name="equalize">
          <description>Levels the floor/ceiling of the selection.</description>
          <remarks>
            <remark>
              default keys , and .
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 2 (ceiling)" />
          </arguments>
        </command>
        <command name="loadsky">
          <description>Loads the skybox P</description>
          <remarks>
            <remark>
              The available textures reside in packages/textures/skymaps/..,
              to select a given set (of 6 images) you need to pass the full path from &quot;packages/&quot; but <i>only up to</i> the underscore &quot;_&quot;.
            </remark>
            <remark>
              Example: loadsky "textures/skymaps/makke/mountain"
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="path to the six skybox textures" valueNotes="string" />
          </arguments>
        </command>
        <command name="heightfield">
          <description>Marks the current selection as a heightfield.</description>
          <remarks>
            <remark>
              marks the current selection as a heightfield, with T being floor or ceiling, as above.
              A surface marked as heightfield will use the vdelta values (see below) of its 4 corners to create a sloped surface.
              To mark a heightfield as normal again (ignoring vdelta values, set or not) use "solid 0".
              Default keys are h (floor) and i (ceiling).
            </remark>
            <remark>
              Heightfields should be made the exact size that is needed, not more not less.
              The most important reason for this is that cube automatically generates "caps" (side-faces for heightfields)
              only on the borders of the heightfield. This also means if you have 2 independant heightfields accidentally
              touch eachother, you will not get correct caps. Also, a heightfield is slightly slower to render than a
              non-heightfield floor or ceiling. Last but not least, a heightfield should have all the same baseheight
              (i.e. the height determined by a normal editheight operation) to get correct results.
            </remark>
          </remarks>
          <references>
            <identifierReference name="vdelta" identifier="vdelta" />
          </references>
          <arguments>
            <argument token="T" description="an integer denoting the type" valueNotes="0 (floor), 2 (ceiling)" />
          </arguments>
        </command>
        <command name="vdelta">
          <description>changes the vdelta value of the current selection</description>
          <remarks>
            <remark>
              Note that unlike all other editing functions, this function doesn't affect a cube, but its top-left vertex
              (market by the dot in the editing cursor). So to edit a N * M heightfield, you will likely have to edit
              the vdelta of (N+1) * (M+1) cubes, i.e. you have to select 1 row and 1 column more in the opposite direction
              of the red dot to affect all the vertices of a heightfield of a given size (try it, it makes sense :)
            </remark>
            <remark>
              A floor delta offsets vertices to beneath the level set by editheight (and a ceil delta to above). Delta offsets have a precision of a quarter of a unit, however you should use non-unitsize vertices only to touch other such vertices. Default keys are 8 and 9 to decrease/increase the vdelta.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="vdelta value" />
          </arguments>
        </command>
        <command name="corner">
          <description>Makes the current selection into a "corner".</description>
          <remarks>
            <remark>
              Currently there is only one type of corner (a 45 degree one), only works on a single unit (cube) at a time.
              It can be positioned either next to 2 solid walls or
              in the middle of 2 higher floorlevels and 2 lower ones forming a diagonal (and similar with ceiling).
            </remark>
            <remark>
              In both cases, the corner will orient itself automatically depending on its neighbours, behaviour with other
              configurations than the 2 above is unspecified. Since the latter configuration generates possibly 2 floor and
              2 ceiling levels, up to 4 textures are used: for example for the 2 floors the higher one will of the cube
              itself, and the lower one of a neighbouring low cube. You can make bigger corners at once by
              issuing "corner" on grid aligned 2x2/4x4/8x8 selections, with equal size solid blocks next to them.
            </remark>
          </remarks>
          <defaultKeys>
            <key alias="K"/>
          </defaultKeys>
        </command>
        <command name="undo">
          <description>Multi-level undo of any of the changes caused by editing operations</description>
          <remarks>
            <remark>hotkey u</remark>
          </remarks>
        </command>
        <command name="undomegs">
          <description>Sets the number of megabytes used for the undo buffer.</description>
          <remarks>
            <remark>
              undo's work for any size areas, so the amount of undo steps per megabyte is more for small areas
              than for big ones (a megabyte fits 280 undo steps on a 16x16 area, but only 4 steps on a 128x128 area).
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="number of megabytes, default is 1" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="copy">
          <description>Copies the current selection into a buffer.</description>
          <remarks>
            <remark>hotkey c</remark>
          </remarks>
        </command>
        <command name="paste">
          <description>Pastes a previously copied selection.</description>
          <remarks>
            <remark>
              To paste a selection back requires a same size selection at the destination location. If it is not the same
              size the selection will be resized automatically prior to the paste operation (with the red dot as anchor),
              which is easier for large selections.
            </remark>
            <remark>
              hotkey v
            </remark>
          </remarks>
        </command>
        <command name="replace">
          <description>Repeats the last texture edit thruout the map.</description>
          <remarks>
            <remark>
              The way it works is intuitive: simply edit any texture anywhere, then using "replace" will replace
              all textures thruout the map in the same way (taking into account wether it was a floor/wall/ceil/upper too).
              If the there was more than one "old" texture in your selection, the one nearest to the red dot is used.
              This operation can't be undone.
            </remark>
          </remarks>
        </command>
        <command name="newent">
          <description>Adds a new entity</description>
          <remarks>
            <remark>
              (x,y) is determined by the current selection (the red dot corner) and z by the camera height, of said type. Type is a string giving the type of entity, such as "light", and may optionally take values (depending on the entity).
            </remark>
          </remarks>
          <arguments>
            <argument token="type" description="the entity type" valueNotes="light, playerstart, clips, ammobox, grenades, health, armour, akimbo, mapmodel, ladder, ctf-flag" />
            <argument token="value1" description="see newent 'type'" />
            <argument token="value2" description="see newent 'type'" />
            <argument token="value3" description="see newent 'type'" />
            <argument token="value4" description="see newent 'type'" />
          </arguments>
        </command>
        <command name="newent light">
          <description>Adds a new light entity</description>
          <remarks>
            <remark>
              if only argument R is specified, it is interpreted as brightness for white light.
            </remark>
          </remarks>
          <arguments>
            <argument token="radius" description="the light radius" valueNotes="1..32" />
            <argument token="R" description="red colour component. see remarks below." valueNotes="1..255" />
            <argument token="G" description="green colour component" valueNotes="1..255" />
            <argument token="B" description="blue colour component" valueNotes="1..255" />
          </arguments>
        </command>
        <command name="newent playerstart">
          <description>Adds a new spawn spot.</description>
          <remarks>
            <remark>The yaw is taken from the current camera yaw.</remark>
          </remarks>
        </command>
        <command name="newent ammobox">
          <description>Adds a new ammo box item.</description>
        </command>
        <command name="newent clips">
          <description>Adds a pistol magazine item.</description>
        </command>
        <command name="newent grenades">
          <description>Adds a new grenades item.</description>
        </command>
        <command name="newent health">
          <description>Adds a new health item.</description>
        </command>
        <command name="newent armour">
          <description>Adds a new armour item.</description>
        </command>
        <command name="newent akimbo">
          <description>Adds a new akimbo item.</description>
        </command>
        <command name="newent mapmodel">
          <description>Adds a map model, i.e. an object rendered as md2/md3 which you collide against but has no behaviour or movement</description>
          <remarks>
            <remark>
              The mapmodel identifier is the desired map model which is defined by the 'mapmodel' command.
              The map texture refers to a texture which is defined by the 'texture' command, if omitted the
              models default skin will be used. The 'mapmodel' and 'texture' commands are placed in the map config normally.
              Mapmodels are more expensive than normal map geometry, do not use insane amounts of them to replace normal geometry.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the mapmodel identifier" valueNotes="integer"/>
            <argument token="Z" description="extra elevation above ground" valueNotes="integer"/>
            <argument token="T" description="the map texture to use (optional)" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="newent ctf-flag">
          <description>Adds a CTF flag entity.</description>
          <remarks>
            <remark>
              Note that this entity is only rendered as flag if the current game mode is CTF.
            </remark>
          </remarks>
          <arguments>
            <argument token="T" description="denotes the flag's team" valueNotes="0 (CLA), 1 (RVSF)"/>
          </arguments>
        </command>
        <command name="newent ladder">
          <description>Adds a ladder entity.</description>
          <remarks>
            <remark>
              Note that this entity is used for physics only, to create a visual ladder you
              will need to add a mapmodel entity too.
            </remark>
          </remarks>
          <references>
            <identifierReference name="newent mapmodel" identifier="newent mapmodel"/>
          </references>
          <arguments>
            <argument token="H" description="the height of the ladder" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="newent sound">
          <description>Adds a sound entity.</description>
          <remarks>
            <remark>
              Will play map-specific sound so long as the player is within the radius.
              However, only up to the max uses allowed for N (specified in the mapsound command) will play, even if the player is within the radius of more N sounds than the max.
              By default (size 0), the sound is a point source. Its volume is maximal at the entity's location, and tapers off to 0 at the radius. If size is specified,
              the volume is maximal within the specified size, and only starts tapering once outside this distance. Radius is always defined as distance from the entity's location,
              so a size greater than or equal to the radius will just make a sound that is always max volume within the radius, and off outside.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="mapsound"/>
          </references>
          <arguments>
            <argument token="N" description="the sound to play" valueNotes="integer"/>
            <argument token="R" description="the radius"/>
            <argument token="S" description="the size" optional="true" valueNotes="default 0"/>
          </arguments>
        </command>
        <command name="delent">
          <description>Deletes the entity closest to the player</description>
          <remarks>
            <remark>hotkey x</remark>
          </remarks>
        </command>
        <command name="entproperty">
          <description>Changes property of the closest entity.</description>
          <remarks>
            <remark>For example 'entproperty 0 2' when executed near a lightsource would increase its radius by 2.</remark>
          </remarks>
          <arguments>
            <argument token="P" description="the property to change" valueNotes="0..3"/>
            <argument token="A" description="amount by wich the property is increased" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="clearents">
          <description>Deletes all entities of said type.</description>
          <arguments>
            <argument token="T" description="the entity type, see command 'newent'" valueNotes="string"/>
          </arguments>
        </command>
        <command name="recalc">
          <description>Recomputes all there is to recompute about a map, currently only lighting.</description>
          <remarks>
            <remark>hotkey R</remark>
          </remarks>
        </command>
        <command name="savemap">
          <description>Saves the current map.</description>
          <remarks>
            <remark>
              savemap makes a versioned backup (mapname_N.BAK) if a map by that name already exists.
              If the name argument is omitted, it is saved under the current map name.
            </remark>
            <remark>
              Where you store a map depends on the complexity of what you are creating: if its a single
              map (maybe with its own .cfg) then the "base" package is the best place. If its multiple maps
              or a map with new media (textures etc.) its better to store it in its own package (a directory under "packages"),
              which makes distributing it less messy.
            </remark>
          </remarks>
          <references>
            <identifierReference name="map" identifier="map"/>
          </references>
          <arguments>
            <argument token="M" description="file name of the map, see command 'map' for the naming scheme" valueNotes="string"/>
          </arguments>
        </command>
        <command name="newmap">
          <description>Creates a new map.</description>
          <remarks>
            <remark>
              The new map has 2^S cubes. For S, 6 is small, 7 medium, 8 large.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="the size of the new map" valueNotes="6..12" />
          </arguments>
        </command>
        <command name="mapenlarge">
          <description>Enlarges the current map.</description>
          <remarks>
            <remark>
              This command will make the current map 1 power of two bigger.
              So a 6 size map (64x64 units) it will become a 7 map (128x128),
              with the old map in the middle (from 32-96) and the new areas solid.
            </remark>
          </remarks>
          <references>
            <identifierReference name="newmap" identifier="newmap"/>
          </references>
        </command>
        <command name="mapmsg">
          <description>Sets the map message, which will be displayed when the map loads.</description>
          <remarks>
            <remark>For example: mapmsg "Map By Author".</remark>
          </remarks>
          <arguments>
            <argument token="M" description="the map message" valueNotes="string"/>
          </arguments>
        </command>
        <command name="waterlevel">
          <description>Sets the global water level for the map.</description>
          <remarks>
            <remark>
              Every cube that has a lower floor than the water level will be rendered with a nice wavy
              water alpha texture. Water physics will be applied to any entity located below it.
            </remark>
            <remark>
              Performance notes: water is rendered for a whole square encapsulating all visible water areas
              in the map (try flying above the map in edit mode to see how). So the most efficient water is
              a single body of water, or multiple water areas that are mostly not visible from eachother.
              Players can influence how accurate the water is rendered using the "watersubdiv" command (map config).
            </remark>
          </remarks>
          <arguments>
            <argument token="H" description="the water level" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="fullbright">
          <description>Sets all light values to fullbright.</description>
          <remarks>
            <remark>Will be reset when you issue a 'recalc'. Only works in edit mode.</remark>
          </remarks>
          <arguments>
            <argument token="B" description="sets fullbright on or off" valueNotes="0 (off), 1 (on)"/>
          </arguments>
        </command>
        <command name="showmip">
          <description>Toggles between showing what parts of the scenery are rendered.</description>
          <remarks>
            <remark>
              Shows what parts of the scenery are rendered using what size cubes, and outputs some statistics about it.
              This can give map editors hints as to what architecture to align, textures to change, etc.
            </remark>,
          </remarks>
        </command>
        <command name="toggleocull">
          <description>Turns occlusion culling on and off.</description>
          <remarks>
            <remark>
              The reason one may want to turn it off is to get an overview of the map from above,
              without having all occluded bits stripped out.
            </remark>
          </remarks>
        </command>
        <command name="texturereset">
          <description>Sets the texture slot to 0 for the subsequent "texture" commands.</description>
        </command>
        <command name="texture">
          <description>Binds a texture to the current texture slot.</description>
          <remarks>
            <remark>
              Binds the texture indicated in filename to the current texture slot, then increments the slot number.
              This is for use in map configs only. A secondary textures can be specified for a single texture slot,
              for use in shaders and other features (unused for now, should be set to 0 to indicate primary texture).
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="number of a secondary texture (unused)" valueNotes="string"/>
            <argument token="F" description="file name of the texture to bind" valueNotes="string"/>
          </arguments>
        </command>
        <command name="slope">
          <description>Makes a slope out of the current selection.</description>
          <remarks>
            <remark>
              The selection must be a heightfield before this command can be used.
              The steps specify the slope with the red vertex as left-top,
              i.e. "slope 1 2" will make a slope that increases just 1 step from left to right,
              and is slightly steeper from top to bottom. "slope -6 0" decreases steeply from left to right,
              and does not slope at all from top to bottom. Note that like the vdelta command,
              an increasing vdelta goes further away from the player, regardless of floor or ceiling.
            </remark>
          </remarks>
          <arguments>
            <argument token="X" description="x delta step" valueNotes="integer"/>
            <argument token="Y" description="y delta step" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="arch">
          <description>Makes an arch out of the current selection.</description>
          <remarks>
            <remark>
              The selection must be a heightfield before this command can be used.
              Will make the arch in the long direction, i.e when you have 6x2 cubes selected, the arch will span 7 vertices.
              Optionally, sidedelta specifies the delta to add to the outer rows of vertices in the other direction,
              i.e. give the impression of an arch that bends 2 ways (try "arch 2" on an selection of atleast 2 thick to see the effect).
              Not all arch sizes are necessarily available, see config/prefabs.cfg.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="side delta (optional)"/>
          </arguments>
        </command>
        <command name="archvertex">
          <description>Defines a vertex delta for a specific arch span prefab, used by the 'arch' command.</description>
          <remarks>
            <remark>See config/prefabs.cfg for an example on usage.</remark>
          </remarks>
          <arguments>
            <argument token="S" description="span value" valueNotes="integer"/>
            <argument token="V" description="vertex value" valueNotes="integer"/>
            <argument token="D" description="delta value" valueNotes="integer"/>
          </arguments>
        </command>
        <command name="perlin">
          <description>Generates a perlin noise landscape in the current selection.</description>
          <remarks>
            <remark>
              Keep the seed the same to create multiple perlin areas which fit with eachother,
              or use different numbers if to create alternative random generations.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="the scale, frequency of the features" valueNotes="default is 10"/>
            <argument token="E" description="the random seed" valueNotes="integer"/>
            <argument token="C" description="cube size, how many cubes to generate a surface for at once (unused)"/>
          </arguments>
        </command>
        <command name="select">
          <description>Selects the given area, as if dragged with the mouse.</description>
          <remarks>
            <remark>
              This command is useful for making complex geometry-generating scripts.
              The current dimensions of the selection (either created by the user or this command)
              are in the variables selx, sely, selxs and selys and can also be read/modified.
            </remark>
            <remark>
              Coordinates are as follows: after a "newmap 6" the top-left corner (the one where the red dot points) are (8,8),
              the opposite corner is (56,56) (or (120,120) on a "newmap 7" etc.).
            </remark>
          </remarks>
          <references>
            <identifierReference name="selx" identifier="selx"/>
            <identifierReference name="sely" identifier="sely"/>
            <identifierReference name="selxs" identifier="selxs"/>
            <identifierReference name="selys" identifier="selys"/>
          </references>
          <arguments>
            <argument token="X" description="the X coordinate"/>
            <argument token="Y" description="the Y coordinate"/>
            <argument token="XS" description="the length along the X axis"/>
            <argument token="XY" description="the length along the Y axis"/>
          </arguments>
        </command>
        <command name="registersound">
          <description>Registers a sound.</description>
          <remarks>
            <remark>
              This command returns the sound number, which is assigned from 0 onwards,
              and which can be used with "sound" command. If the sound was already registered,
              its existing index is returned. registersound does not actually load the sound, this is done on first play.
            </remark>
            <remark>
              See for example config/sounds.cfg.
            </remark>
          </remarks>
          <references>
            <identifierReference name="sound" identifier="sound"/>
          </references>
          <arguments>
            <argument token="N" description="sound name" valueNotes="string, see config/sounds.cfg"/>
          </arguments>
        </command>
        <command name="mapsound">
          <description>Defines a mapsound.</description>
          <remarks>
            <remark>
              Registers the sound as a map-specific sounds. These map-specific sounds may currently only be used with "sound" entities within a map. The first map sound registered in a map has index 0, and increases afterwards.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="newent sound"/>
          </references>
          <arguments>
            <argument token="N" description="path to the sound file"></argument>
            <argument token="V" description="volume adjustment" optional="true" valueNotes="1..255, default is 0"/>
            <argument token="M" description="maximum simultaneous sounds" optional="true" valueNotes="default 0 (unlimited)"/>
          </arguments>
        </command>
        <command name="mapmodelreset">
          <description>Resets the mapmodel slots/indices to 0.</description>
          <remarks>
            <remark>Each subsequent mapmodel command increases it again. See config/default_map_settings.cfg for an example.</remark>
          </remarks>
        </command>
        <command name="mapmodel">
          <description>Registers a mapmodel that can be placed in maps.</description>
          <remarks>
            <remark>
              A map model registered with this command can be placed in a map using the 'newent mapmodel' command.
              All of these values are used for collision as well as rendering. Specifying a snap can be useful
              for architectural mapmodels, as the md2 format doesn't provide exact vertex coordinates.
            </remark>
            <remark>
              Example: mapmodel 4 2 4 2 this map model is 8x8x2 in size (x,y,z), by default hovers 4 units above ground,
              and has all coordinates snapped to the nearest even number. See data/models.cfg.
            </remark>
          </remarks>
          <arguments>
            <argument token="R" description="the square radius" valueNotes="string"/>
            <argument token="H" description="the height" valueNotes="integer"/>
            <argument token="Z" description="the initial Z-offset above ground" valueNotes="integer"/>
            <argument token="S" description="the snap value in 16ths of a cube unit" valueNotes="integer, 0 meaning no snap"/>
            <argument token="N" description="the name of the map model" valueNotes="string"/>
          </arguments>
        </command>
        <command name="scalelights">
          <description>Scales all lights in the map.</description>
          <remarks>
            <remark>
              This command is useful if a map is too dark or bright but you want to keep the light entities where they are.
            </remark>
          </remarks>
          <arguments>
            <argument token="P" description="percentage"/>
            <argument token="I" description="intensity"/>
          </arguments>
        </command>
        <variable name="editing">
          <description>A variable indicating if the game is in editmode.</description>
          <value description="editmode" minValue="0" maxValue="1" readOnly="true" valueNotes="1 (true), 0 (false)" defaultValue="0"/>
        </variable>
        <variable name="flrceil">
          <description>A variable indicating if the player looks at the floor or at the ceiling.</description>
          <value description="flrceil" minValue="0" maxValue="2" readOnly="true" valueNotes="0 (floor), 2 (ceiling)" defaultValue="0"/>
        </variable>
      </identifiers>
    </section>
    <section name="Menu" sortindex="7">
      <description>This section describes identifiers related to the menu gui.</description>
      <identifiers>
        <command name="menuinit">
          <description>Specifies a block of commands to be executed when menu opens.</description>
          <references>
            <identifierReference identifier="newmenu"/>
          </references>
          <arguments>
            <argument token="C" description="the code to execute on init"/>
          </arguments>
        </command>
        <command name="newmenu">
          <description>Creates a new menu.</description>
          <references>
            <identifierReference identifier="menuitem"/>
          </references>
          <arguments>
            <argument token="N" description="the name of the menu"/>
          </arguments>
        </command>
        <command name="menuitem">
          <description>Creates a new menuitem.</description>
          <remarks>
            <remark>
              If the action argument is omitted,
              then it will be set to the same value as the description.
              Upon pressing return, the associated action will be executed.
              See config/menus.cfg for examples.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="newmenu"/>
          </references>
          <arguments>
            <argument token="N" description="the name of the menuitem"/>
            <argument token="A" description="the action on selection" optional="true"/>
          </arguments>
        </command>
        <command name="showmenu">
          <description>Displays the specified menu.</description>
          <remarks>
            <remark>
              The menu allows the user to pick an item with the cursor keys.
              Upon pressing return, the associated action will be executed.
              Pressing ESC will cancel the menu.
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the name of a previously defined menu"/>
          </arguments>
        </command>
        <command name="menumdl">
          <description>Specifies a model to render while displaying the last added menu.</description>
          <arguments>
            <argument token="M" description="the model"/>
            <argument token="A" description="the animation to play"/>
            <argument token="R" description="the rotation speed"/>
            <argument token="S" description="the scale"/>
          </arguments>
        </command>
        <command name="chmenumdl">
          <description>Changes the menu model of a specified menu.</description>
          <references>
            <identifierReference identifier="menumdl"/>
          </references>
          <arguments>
            <argument token="N" description="the name of the menu"/>
            <argument token="M" description="the (new) model"/>
            <argument token="A" description="the animation to play"/>
            <argument token="R" description="the rotation speed"/>
            <argument token="S" description="the scale"/>
          </arguments>
        </command>
      </identifiers>
    </section>
    <section name="HUD" sortindex="5">
      <description>This section describes the identifiers to configure the head-up display (HUD).</description>
      <identifiers>
        <command name="clearminimap">
          <description>Recreates the minimap for the current map.</description>
          <references>
            <identifierReference identifier="minimapres"/>
          </references>
        </command>
        <command name="history">
          <description>Executes the specified command in the command line history.</description>
          <remarks>
            <remark>
              For example, binding "history 1" to a key allows you to quickly repeat the last
              command typed in (useful for placing many identical entities etc.)
            </remark>
          </remarks>
          <arguments>
            <argument token="N" description="the N'th command from the history"/>
          </arguments>
        </command>
        <command name="conskip">
          <description>
            Allows to browse through the console history by offsetting the console output.
          </description>
          <defaultKeys>
            <key alias="KP_MINUS" name="- on the keypad" description="scrolls into the history (conskip 1)"/>
            <key alias="KP_PLUS" name="+ on the keypad" description="resets the history (conskip -1000)"/>
          </defaultKeys>
          <arguments>
            <argument token="N" description="the offset"/>
          </arguments>
        </command>
        <variable name="minimapres">
          <description>Sets the resolution for the minimap.</description>
          <references>
            <identifierReference identifier="clearminimap"/>
          </references>
          <value token="N" description="the resoution" minValue="7" maxValue="10" defaultValue="9"/>
        </variable>
        <variable name="confade">
          <value token="V" description="" minValue="0" maxValue="60" defaultValue="20" />
        </variable>
        <variable name="consize">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="6" />
        </variable>
        <variable name="aboveheadiconfadetime">
          <value token="V" description="" minValue="1" maxValue="10000" defaultValue="2000" />
        </variable>
        <variable name="hideconsole">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hidehudequipment">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hidehudmsgs">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hidespecthud">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hidectfhud">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hideteam">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hideradar">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hidevote">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="hudgun">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="hidestats">
          <description>Turns on/off display of fps/rendering stats on the HUD.</description>
          <value token="B" description="Turns the stats off (1) or on (0)" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>
        <variable name="recoiltest">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="recoilbackfade">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="100" />
        </variable>
        <variable name="recoilbase">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="40" />
        </variable>
        <variable name="recoilincrease">
          <value token="V" description="" minValue="1" maxValue="10" defaultValue="2" />
        </variable>
        <variable name="swaymovediv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="200" />
        </variable>
        <variable name="swayspeeddiv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="105" />
        </variable>
        <variable name="swayupmovediv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="200" />
        </variable>
        <variable name="swayupspeeddiv">
          <value token="V" description="" minValue="1" maxValue="1000" defaultValue="105" />
        </variable>
        <variable name="crosshairteamsign">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="damageindicatoralpha">
          <value token="V" description="" minValue="1" maxValue="100" defaultValue="50" />
        </variable>
        <variable name="damageindicatordist">
          <value token="V" description="" minValue="0" maxValue="10000" defaultValue="500" />
        </variable>
        <variable name="damageindicatorsize">
          <value token="V" description="" minValue="0" maxValue="10000" defaultValue="200" />
        </variable>
        <variable name="damageindicatortime">
          <value token="V" description="" minValue="1" maxValue="10000" defaultValue="1000" />
        </variable>
        <variable name="crosshairsize">
          <description>Sets the size of your crosshair.</description>
          <remarks>
            <remark>
              The crosshair is turned off entirely if the size is set to 0.
            </remark>
          </remarks>
          <value token="N" description="the crosshair size" minValue="0" maxValue="50" defaultValue="15"/>
        </variable>
        <variable name="crosshairfx">
          <description>Turns on or off crosshair effects.</description>
          <remarks>
            <remark>
              When on, the crosshair will go grey when the weapon is reloading, orange when health se 50 or red when se 25.
            </remark>
          </remarks>
          <value token="B" description="Turns the effects on (1) or off (0)" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>
        <variable name="nosway">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="radarentsize">
          <value token="V" description="" minValue="1" maxValue="64" defaultValue="4" />
        </variable>
        <variable name="radarres">
          <value token="V" description="" minValue="1" maxValue="1024" defaultValue="64" />
        </variable>
      </identifiers>
    </section>
    <section name="Visuals" sortindex="4">
      <description>This section describes identifiers to configure the visuals.</description>
      <identifiers>
        <command name="fov">
          <description>Sets the field of view (fov).</description>
          <arguments>
            <argument token="N" description="the fov value" valueNotes="90..120" defaultValue="100" />
          </arguments>
        </command>
        <command name="font">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <command name="fontchar">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <variable name="aboveheadiconsize">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="50" />
        </variable>
        <variable name="bloodttl">
          <value token="V" description="" minValue="0" maxValue="30000" defaultValue="10000" />
        </variable>
        <variable name="blood">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="gibnum">
          <description>Sets the number of gibs to display when performing a "messy" kill (grenade, knife, sniper headshot).</description>
          <value token="N" description="number of gibs" minValue="0" maxValue="1000" defaultValue="6"/>
          <remarks>
            <remark>Larger values are more spectacular, but can slow down less powerful machines. Reducing gibttl may help in this case.</remark>
          </remarks>
          <references>
            <identifierReference identifier="gibttl"/>
            <identifierReference identifier="gibspeed"/>
          </references>
        </variable>
        <variable name="gibttl">
          <description>Sets the time for gibs to live (in milliseconds), after which they will disappear.</description>
          <value token="N" description="time to live" minValue="0" maxValue="15000" defaultValue="5000"/>
          <references>
            <identifierReference identifier="gibnum"/>
            <identifierReference identifier="gibspeed"/>
          </references>
        </variable>
        <variable name="gibspeed">
          <description>Sets the velocity at which gibs will fly from a victim.</description>
          <value token="N" description="velocity" minValue="1" maxValue="100" defaultValue="30"/>
          <references>
            <identifierReference identifier="gibnum"/>
            <identifierReference identifier="gibttl"/>
          </references>
        </variable>
        <variable name="teamdisplaymode">
          <description>Sets the team display mode.</description>
          <remarks>
            <remark>
              In mode 0 team display is disabled
              In mode 1 players will be rendered with a colored vest to make the teams distinguishable.
              In mode 2 almost the whole suit of the players will be colored. These display modes are only
              applied in team gamemodes.
            </remark>
          </remarks>
          <value token="N" description="the team display mode" minValue="0" maxValue="2" defaultValue="1" valueNotes="0 (none), 1 (color vests), 2 (color skins)"/>
        </variable>
        <variable name="aadynshadow">
          <description>Sets the size/resolution of the dynamic shadow data.</description>
          <value description="the size" minValue="0" maxValue="3" defaultValue="2"/>
        </variable>
        <variable name="dynshadowsize">
          <description>Sets the display size of the dynamic shadows.</description>
          <value description="the size" minValue="4" maxValue="8" defaultValue="5"/>
        </variable>
        <variable name="saveshadows">
          <description>Sets if dynamic shadows should be saved to disk.</description>
          <value description="auto save" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>
        <variable name="dynshadow">
          <description>Sets the alpha value (transparency) for dynamic shadows.</description>
          <value description="the alpha value" minValue="0" maxValue="100" defaultValue="40"/>
        </variable>
        <variable name="bilinear">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="scorchttl">
          <value token="V" description="" minValue="0" maxValue="30000" defaultValue="10000" />
        </variable>
        <variable name="scorch">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="mtexplosion">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="mtwater">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="reflectclip">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="3" />
        </variable>
        <variable name="reflectsize">
          <value token="V" description="" minValue="6" maxValue="10" defaultValue="8" />
        </variable>
        <variable name="reflectscissor">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="dynlight">
          <description>Determines wether dynamic shadows and lights are rendered, providedjust incase they slow your fps down too much.</description>
          <remarks>
            <remark>
              With radius you can specify the radius of a dynamic light,
              smaller to maybe gain some speed (0 is off entirely),
              or bigger to see the effect of dynamic shadows more dramatically
              (try shooting it past some pillars that have a dark area on the other side... or use the "gamespeed" variable).
            </remark>
          </remarks>
          <value token="R" description="the radius of a dynamic light" minValue="0" maxValue="32" defaultValue="16"/>
        </variable>
        <variable name="watersubdiv">
          <description>Determines the subdivision of the water surface in maps.</description>
          <remarks>
            <remark>
              Must be a power of 2: 4 is the default, 8 is recommended for people on slow machines,
              2 is nice for fast machines, and 1 is quite OTT. See "waterlevel" (edit reference)
              on how to add water to your own levels.
            </remark>
          </remarks>
          <value token="N" description="the subdivisioin value" minValue="1" maxValue="64" defaultValue="4"/>
        </variable>
        <variable name="waterreflect">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="waterrefract">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="0" />
        </variable>
        <variable name="shotlinettl">
          <value token="V" description="" minValue="0" maxValue="10000" defaultValue="75" />
        </variable>
        <variable name="shotline">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="fullscreen">
          <description>Enables or disables fullscreen.</description>
          <remarks>
            <remark>Not supported on Windows and Mac.</remark>
          </remarks>
          <value description="fullscreen" minValue="0" maxValue="1" defaultValue="1"/>
        </variable>
        <variable name="fsaa">
          <description>Sets the level of fullscreen antialiasing (FSAA).</description>
          <value description="fsaa" minValue="0" maxValue="16" defaultValue="0"/>
        </variable>
        <variable name="scr_w">
          <description>Sets the screen width.</description>
          <value description="the screen width" minValue="0" maxValue="1024" defaultValue="10000"/>
        </variable>
        <variable name="scr_h">
          <description>Sets the screen height.</description>
          <value description="the screen height" minValue="0" maxValue="768" defaultValue="10000"/>
        </variable>
        <variable name="colorbits">
          <description>Sets the bits per pixel value.</description>
          <value description="bits per pixel" minValue="0" maxValue="32" defaultValue="0"/>
        </variable>
        <variable name="depthbits">
          <description>Sets the bits for the depth buffer.</description>
          <value description="depth pixels" minValue="0" maxValue="32" defaultValue="0"/>
        </variable>
        <variable name="vsync">
          <description>Enables or disables vsync.</description>
          <value description="vsync" minValue="-1" maxValue="1" defaultValue="-1"/>
        </variable>
        <variable name="gamma">
          <description>Sets the hardware gamma value.</description>
          <remarks>
            <remark>
              May not work if your card/driver doesn't support it.
            </remark>
          </remarks>
          <value token="N" description="the gamma value" minValue="30" maxValue="300" defaultValue="100"/>
        </variable>
        <variable name="lighterror">
          <description>Allows to finetune the amount of "error" the mipmapper/stripifier allow themselves for changing lightlevels.</description>
          <remarks>
            <remark>
              If this variable is changed this during play,
              a "recalc" is needed to see the effect.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="recalc"/>
          </references>
          <value token="E" description="the error value, 1 being the best quality" minValue="1" maxValue="100" defaultValue="8" readOnly="false"/>
        </variable>
        <variable name="spectfov">
          <value token="V" description="" minValue="5" maxValue="120" defaultValue="120" />
        </variable>
        <variable name="hwtexsize">
          <value token="V" description="" minValue="1" maxValue="0" defaultValue="0" />
        </variable>
        <variable name="maxtexsize">
          <value token="V" description="" minValue="0" maxValue="4096" defaultValue="0" />
        </variable>
        <variable name="trilinear">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="bulletholettl">
          <value token="V" description="" minValue="0" maxValue="30000" defaultValue="10000" />
        </variable>
        <variable name="bullethole">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="particlesize">
          <description>Scales all particles.</description>
          <value token="P" description="the scale percentage" minValue="20" maxValue="500" defaultValue="100"/>
        </variable>
        <variable name="animationinterpolationtime">
          <description>Sets the time available for interpolation between model animations.</description>
          <value token="N" description="the amount of milliseconds for the interpolation" minValue="0" maxValue="1000" defaultValue="100" />
        </variable>
        <variable name="mergestrips">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
      </identifiers>
    </section>
    <section name="Sound" sortindex="6">
      <description>This section describes all identifiers related to music and sound effects.</description>
      <identifiers>
        <command name="musicvol">
          <description>Sets the music volume.</description>
          <references>
            <identifierReference name="soundvol" identifier="soundvol"/>
          </references>
          <arguments>
            <argument token="N" description="the volume" valueNotes="0..255"/>
          </arguments>
        </command>
        <command name="sound">
          <description>Plays the specified sound.</description>
          <remarks>
            <remark>
              See config/sounds.cfg for default sounds, and use registersound to register your own.
              For example, sound 0 and  sound (registersound "aard/jump") both play the standard jump sound.
            </remark>
          </remarks>
          <arguments>
            <argument token="S" description="the sound to play" valueNotes="string, see config/sounds.cfg"/>
          </arguments>
        </command>
        <variable name="bulletairsounddestrad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="8" />
        </variable>
        <variable name="bulletairsoundrad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="15" />
        </variable>
        <variable name="bulletairsoundsourcerad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="8" />
        </variable>
        <variable name="bulletairsound">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="bulletbouncesoundrad">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="15" />
        </variable>
        <variable name="bulletbouncesound">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>
        <variable name="maxsoundsatonce">
          <value token="V" description="" minValue="0" maxValue="100" defaultValue="40" />
        </variable>
        <variable name="soundvol">
          <description>Sets the sound volume.</description>
          <value token="N" description="the volume" minValue="0" maxValue="255" defaultValue="155"/>
        </variable>
      </identifiers>
    </section>
    <section name="Ingame Reference" sortindex="8">
      <description>This section describes all indentifiers related to the ingame documentation reference.</description>
      <identifiers>
        <command name="docsection">
          <description>Adds a new section to the ingame documentation.</description>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="S" description="the section name"/>
          </arguments>
        </command>
        <command name="docident">
          <description>Adds a new identifier documentation to the last added section.</description>
          <remarks>
            <remark>
              An identifier represents a command or variable. The new identifier
            </remark>
            <remark>
              The name may countain spaces to create a "multipart" identifier documentation
              that can be used to describe a complex argument as a single pseudo identifier,
              look at the examples.
            </remark>
          </remarks>
          <examples>
            <example>
              <code>docident fov "Sets the field of view."</code>
            </example>
            <example>
              <code>docident "newent light" "Adds a new light entitiy."</code>
            </example>
          </examples>
          <references>
            <identifierReference identifier="docsection"/>
            <identifierReference identifier="docargument"/>
            <identifierReference identifier="docremark"/>
            <identifierReference identifier="docref"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
            <identifierReference identifier="docwritebaseref"/>
          </references>
          <arguments>
            <argument token="N" description="name of the identifier"/>
            <argument token="D" description="the description"/>
          </arguments>
        </command>
        <command name="docargument">
          <description>Adds a new argument documentation to the last added identifier.</description>
          <remarks>
            <remark>
              An argument represents either a command argument or a variable value.
            </remark>
            <remark>
              The last argument of an identifier can be flagged as variable-length
              to indicate that it represents an unknown number of arguments.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="T" description="the token"/>
            <argument token="D" description="the description"/>
            <argument token="V" description="the value notes"/>
            <argument token="I" description="flags this argument as variable-length" valueNotes="1 (true), 0 (false)" optional="true"/>
          </arguments>
        </command>
        <command name="docremark">
          <description>Adds a new documentation remark to the last added identifier.</description>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="S" description="the remark"/>
          </arguments>
        </command>
        <command name="docexample">
          <description>Adds an example to the last added identifier.</description>
          <arguments>
            <argument token="C" description="the example code"/>
            <argument token="E" description="the explanation" optional="true"/>
          </arguments>
        </command>
        <command name="docref">
          <description>Adds a new documentation reference to an identifier.</description>
          <remarks>
            <remark>
              The new reference is added to the last added identifier documentation.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
          </references>
          <arguments>
            <argument token="N" description="the display name"/>
            <argument token="I" description="the identifier to refer to" optional="true"/>
            <argument token="U" description="the URL to refer to" optional="true"/>
          </arguments>
        </command>
        <command name="docundone">
          <description>Outputs a list of yet undocumented identifiers (commands,variables, etc)</description>
          <remarks>
            <remark>
              If the one argument is omitted, only the builtin identifiers will be listed. Therefore specify the argument
              other identifers like aliases should be included too.
            </remark>
            <remark>
              Note that the list also includes identifiers that contain the substrings "TODO" or "UNDONE" in their documentation.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
          </references>
          <arguments>
            <argument token="A" description="output all identifiers" valueNotes="1 (true), 0 (false)" optional="true"/>
          </arguments>
        </command>
        <command name="docinvalid">
          <description>Outputs a list of identifer documentations that do not match any existing identifer.</description>
          <remarks>
            <remark>
              Multipart identifiers are not included in this list, see 'docident'.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
          </references>
        </command>
        <command name="docfind">
          <description>Searches the ingame docs for identifier documentations matching the specified search string.</description>
          <remarks>
            <remark>
              The name, description and remarks are included in the search.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docinvalid"/>
          </references>
          <arguments>
            <argument token="S" description="the search string"/>
          </arguments>
        </command>
        <command name="docwritebaseref">
          <description>Writes out a base XML documentation reference containing templates for the builtin identifiers.</description>
          <remarks>
            <remark>
              The generated reference is written to "config/autogenerated_base_reference.xml" by default.
              The three arguments can be changed later on in the generated XML document.
            </remark>
          </remarks>
          <references>
            <identifierReference identifier="docident"/>
            <identifierReference identifier="docundone"/>
            <identifierReference identifier="docinvalid"/>
            <identifierReference identifier="docfind"/>
          </references>
          <arguments>
            <argument token="R" description="the reference name" optional="true"/>
            <argument token="S" description="the XML schema location string" optional="true"/>
            <argument token="T" description="XML stylesheet to use" optional="true"/>
          </arguments>
        </command>        
        <command name="dockey">
          <argument token="A" description="" valueNotes="value" />
        </command>
        <variable name="docskip">
          <value token="V" description="" minValue="0" maxValue="1000" defaultValue="0" />
        </variable>
        <variable name="docvisible">
          <value token="V" description="" minValue="0" maxValue="1" defaultValue="1" />
        </variable>        
      </identifiers>
    </section>
  </sections>    
</cuberef>
