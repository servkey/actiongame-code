// auto generated script to make the command reference readable for ActionCube
docsection [Editing Reference]
 
docident [edittoggle] [switches between map edit mode and normal.];
docremark [In map edit mode you can select bits of the map by clicking or dragging your crosshair on the floor or ceiling (using the "attack" identifier, normally MOUSE1), then use the identifiers below to modify the selection. While in edit mode, physics and collision don't apply (noclip), and key repeat is ON. Note that if you fly outside the map, cube still renders the world as if you were standing on the floor directly below the camera.];
docremark [Hotkey E];
docref [The Editing Mode] [] [http://wiki.cubers.net/wiki/EditingMode];
docref [select] [select] [];
docref [Mappers Readme] [] [];
 
docident [edittex] [Changes the texture on current selection by browsing through a list of textures directly shown on the cubes.];
docargument [T] [an integer denoting the type] [0 (floor), 1 (lower or wall), 2 (ceiling), 3 (upper wall)];
docargument [D] [the direction you want to cycle the textures in] [1 (forwards), -1 (backwards)];
docremark [Default keys are the six keys above the cursor keys, which each 2 of them cycle one type (and numpad 7/4 for upper).];
docremark [The way this works is slightly strange at first, but allows for very fast texture assignment. All textures are in 3 individual lists for each type (both wall kinds treated the same), and each time a texture is used, it is moved to the top of the list. So after a bit of editing, all your most frequently used textures will come first when pressing these keys, and the most recently used texture is set immediately when you press the forward key for the type. These lists are saved with the map. make a selection (including wall bits) and press these keys to get a feel for what they do.];
 
docident [editheight] [Changes the height of the current selection.];
docargument [T] [an integer denoting the type] [0 (floor), 2 (ceiling)];
docargument [D] [the delta value to move it in] [1 (forwards), -1 (backwards)];
docremark [Default keys are [ and ] for floor level, and o/p for ceiling.];
 
docident [solid] [makes the current selection all solid (i.e. wall) or all non-solid.];
docargument [B] [an integer denoting the solid-ness] [0 (non-solid), 1..* (solid)];
docremark [This operation retains floor/ceiling heights/textures while swapping between the two. Default keys f and g respectively.];
 
docident [equalize] [Levels the floor/ceiling of the selection.];
docargument [T] [an integer denoting the type] [0 (floor), 2 (ceiling)];
docremark [default keys , and .];
 
docident [heighfield] [Marks the current selection as a heightfield.];
docargument [T] [an integer denoting the type] [0 (floor), 2 (ceiling)];
docremark [marks the current selection as a heightfield, with T being floor or ceiling, as above. A surface marked as heightfield will use the vdelta values (see below) of its 4 corners to create a sloped surface. To mark a heightfield as normal again (ignoring vdelta values, set or not) use "solid 0". Default keys are h (floor) and i (ceiling).];
docremark [Heightfields should be made the exact size that is needed, not more not less. The most important reason for this is that cube automatically generates "caps" (side-faces for heightfields) only on the borders of the heighfield. This also means if you have 2 independant heightfields accidentally touch eachother, you will not get correct caps. Also, a heighfield is slightly slower to render than a non-heighfield floor or ceiling. Last but not least, a heightfield should have all the same baseheight (i.e. the height determined by a normal editheight operation) to get correct results.];
docref [vdelta] [vdelta] [];
 
docident [vdelta] [changes the vdelta value of the current selection];
docargument [N] [vdelta value] [];
docremark [Note that unlike all other editing functions, this function doesn't affect a cube, but its top-left vertex (market by the dot in the editing cursor). So to edit a N * M heightfield, you will likely have to edit the vdelta of (N+1) * (M+1) cubes, i.e. you have to select 1 row and 1 column more in the opposite direction of the red dot to affect all the vertices of a heightfield of a given size (try it, it makes sense :)];
docremark [A floor delta offsets vertices to beneath the level set by editheight (and a ceil delta to above). Delta offsets have a precision of a quarter of a unit, however you should use non-unitsize vertices only to touch other such vertices. Default keys are 8 and 9 to decrease/increase the vdelta.];
 
docident [corner] [Makes the current selection into a "corner".];
docremark [Currently there is only one type of corner (a 45 degree one), only works on a single unit (cube) at a time. It can be positioned either next to 2 solid walls or in the middle of 2 higher floorlevels and 2 lower ones forming a diagonal (and similar with ceiling).];
docremark [In both cases, the corner will orient itself automatically depending on its neighbours, behaviour with other configurations than the 2 above is unspecified. Since the latter configuration generates possibly 2 floor and 2 ceiling levels, up to 4 textures are used: for example for the 2 floors the higher one will of the cube itself, and the lower one of a neighbouring low cube. Default key = k you can make bigger corners at once by pressing "corner" on grid aligned 2x2/4x4/8x8 selections, with equal size solid blocks next to them.];
 
docident [undo] [Multi-level undo of any of the changes caused by editing operations];
docremark [hotkey u];
 
docident [undomegs] [Sets the number of megabytes used for the undo buffer.];
docargument [N] [number of megabytes, default is 1] [integer];
docremark [undo's work for any size areas, so the amount of undo steps per megabyte is more for small areas than for big ones (a megabyte fits 280 undo steps on a 16x16 area, but only 4 steps on a 128x128 area).];
 
docident [copy] [Copies the current selection into a buffer.];
docremark [hotkey c];
 
docident [paste] [Pastes a previously copied selection.];
docremark [To paste a selection back requires a same size selection at the destination location. If it is not the same size the selection will be resized automatically prior to the paste operation (with the red dot as anchor), which is easier for large selections.];
docremark [hotkey v];
 
docident [replace] [Repeats the last texture edit thruout the map.];
docremark [The way it works is intuitive: simply edit any texture anywhere, then using "replace" will replace all textures thruout the map in the same way (taking into account wether it was a floor/wall/ceil/upper too). If the there was more than one "old" texture in your selection, the one nearest to the red dot is used. This operation can't be undone.];
 
docident [newent] [Adds a new entity];
docargument [type] [the entity type] [light, playerstart, clips, ammobox, grenades, health, armour, akimbo, mapmodel, trigger, ladder, ctf-flag];
docargument [value1] [see newent 'type'] [];
docargument [value2] [see newent 'type'] [];
docargument [value3] [see newent 'type'] [];
docargument [value4] [see newent 'type'] [];
docremark [(x,y) is determined by the current selection (the red dot corner) and z by the camera height, of said type. Type is a string giving the type of entity, such as "light", and may optionally take values (depending on the entity).];
 
docident [newent light] [Adds a new light entity];
docargument [radius] [the light radius] [1..32];
docargument [R] [red colour component. see remarks below.] [1..255];
docargument [G] [green colour component] [1..255];
docargument [B] [blue colour component] [1..255];
docremark [if only argument R is specified, it is interpreted as brightness for white light.];
 
docident [newent playerstart] [Adds a new spawn spot.];
docremark [The yaw is taken from the current camera yaw.];
 
docident [newent ammo] [Adds a new ammo box item.];
 
docident [newent clips] [Adds a new clip item.];
 
docident [newent grenades] [Adds a new grenades item.];
 
docident [newent health] [Adds a new health item.];
 
docident [newent armour] [Adds a new armour item.];
 
docident [newent armour] [Adds a new akimbo item.];
 
docident [newent teleport] [Creates a teleport connection.];
docargument [N] [the teleport identifier] [0..255];
docremark [Teleports are linked to a teledest with the same identifier.];
docref [teledest] [teledest] [];
 
docident [newent teledest] [Creates a teleport destination.];
docargument [N] [the teleport identifier] [0..255];
docremark [Teleports are linked to a teledest with the same identifier. The teledest uses the current camera yaw.];
 
docident [newent mapmodel] [Adds a map model, i.e. an object rendered as md2/md3 which you collide against but has no behaviour or movement];
docargument [N] [the mapmodel identifier] [integer];
docargument [Z] [extra elevation above ground] [integer];
docargument [T] [the map texture to use (optional)] [integer];
docremark [The mapmodel identifier is the desired map model which is defined by the 'mapmodel' command. The map texture refers to a texture which is defined by the 'texture' command, if omitted the models default skin will be used. The 'mapmodel' and 'texture' commands are placed in the map config normally. Mapmodels are more expensive than normal map geometry, do not use insane amounts of them to replace normal geometry.];
 
docident [delent] [Deletes the entity closest to the player];
docremark [hotkey x];
 
docident [entproperty] [Changes property of the closest entity.];
docargument [P] [the property to change] [0..3];
docargument [A] [amount by wich the property is increased] [integer];
docremark [For example 'entproperty 0 2' when executed near a lightsource would increase its radius by 2.];
 
docident [clearents] [Deletes all entities of said type.];
docargument [T] [the entity type, see command 'newent'] [string];
docremark [];
 
docident [recalc] [Recomputes all there is to recompute about a map, currently only lighting.];
docremark [hotkey R];
 
docident [map] [Loads up a map in the gamemode set previously by the 'mode' command.];
docargument [M] [name of the map to load] [string];
docremark [A map given as "blah" refers to "packages/base/blah.cgz", "mypackage/blah" refers to "packages/mypackage/blah.cgz". At every map load, "config/default_map_settings.cfg" is loaded which sets up all texture definitions, etc. Everything defined in there can be overridden per package or per map by creating a "package.cfg" or "mapname.cfg" which contains whatever you want to do differently from the default.];
docremark [When the map finishes it will load the next map when one is defined, otherwise reloads the current map. You can define what map follows a particular map by making an alias like (in the map script): alias nextmap_blah1 blah2 (loads "blah2" after "blah1").];
 
docident [savemap] [Saves the current map.];
docargument [M] [file name of the map, see command 'map' for the naming scheme] [string];
docremark [savemap makes a versioned backup (mapname_N.BAK) if a map by that name already exists. If the name argument is omitted, it is saved under the current map name.];
docremark [Where you store a map depends on the complexity of what you are creating: if its a single map (maybe with its own .cfg) then the "base" package is the best place. If its multiple maps or a map with new media (textures etc.) its better to store it in its own package (a directory under "packages"), which makes distributing it less messy.];
docref [map] [map] [];
 
docident [newmap] [Creates a new map.];
docargument [S] [the size of the new map] [6..12];
docremark [The new map has 2^S cubes. For S, 6 is small, 7 medium, 8 large.];
 
docident [mapenlarge] [Enlarges the current map.];
docremark [This command will make the current map 1 power of two bigger. So a 6 size map (64x64 units) it will become a 7 map (128x128), with the old map in the middle (from 32-96) and the new areas solid.];
docref [newmap] [newmap] [];
 
docident [mapmsg] [Sets the map message, which will be displayed when the map loads.];
docargument [M] [the map message] [string];
docremark [For example: mapmsg "Map By Author".];
 
docident [waterlevel] [Sets the global water level for the map.];
docargument [H] [the water level] [integer];
docremark [Every cube that has a lower floor than the water level will be rendered with a nice wavy water alpha texture. Water physics will be applied to any entity located below it.];
docremark [Performance notes: water is rendered for a whole square encapsulating all visible water areas in the map (try flying above the map in edit mode to see how). So the most efficient water is a single body of water, or multiple water areas that are mostly not visible from eachother. Players can influence how accurate the water is rendered using the "watersubdiv" command (map config).];
 
docident [fullbright] [Sets all light values to fullbright.];
docargument [B] [sets fullbright on or off] [0 (off), 1 (on)];
docremark [Will be reset when you issue a 'recalc'. Only works in edit mode.];
 
docident [showmip] [Toggles between showing what parts of the scenery are rendered.];
docremark [Shows hat parts of the scenery are rendered using what size cubes, and outputs some stats too. This can give mappers hints as to what architecture to align / textures to change etc.];
 
docident [toggleocull] [Turns occlusion culling on and off.];
docremark [The reason one may want to turn it off is to get an overview of the map from above, without having all occluded bits stripped out.];
 
docident [texturereset] [Sets the texture slot to 0 for the subsequent "texture" commands.];
 
docident [texture] [Binds a texture to the current texture slot.];
docargument [S] [number of a secondary texture (unused)] [string];
docargument [F] [file name of the texture to bind] [string];
docremark [Binds the texture indicated in filename to the current texture slot, then increments the slot number. This is for use in map configs only. A secondary textures can be specified for a single texture slot, for use in shaders and other features (unused for now, should be set to 0 to indicate primary texture).];
 
docident [slope] [Makes a slope out of the current selection.];
docargument [X] [x delta step] [integer];
docargument [Y] [y delta step] [integer];
docremark [The selection must be a heighfield before this command can be used. The steps specify the slope with the red vertex as left-top, i.e. "slope 1 2" will make a slope that increases just 1 step from left to right, and is slightly steeper from top to bottom. "slope -6 0" decreases steeply from left to right, and does not slope at all from top to bottom. Note that like the vdelta command, an increasing vdelta goes further away from the player, regardless of floor or ceiling.];
 
docident [arch] [Makes an arch out of the current selection.];
docargument [S] [side delta (optional)] [];
docremark [The selection must be a heighfield before this command can be used. Will make the arch in the long direction, i.e when you have 6x2 cubes selected, the arch will span 7 vertices. Optionally, sidedelta specifies the delta to add to the outer rows of vertices in the other direction, i.e. give the impression of an arch that bends 2 ways (try "arch 2" on an selection of atleast 2 thick to see the effect). Not all arch sizes are necessarily available, see config/prefabs.cfg.];
 
docident [archvertex] [Defines a vertex delta for a specific arch span prefab, used by the 'arch' command.];
docargument [S] [span value] [integer];
docargument [V] [vertex value] [integer];
docargument [D] [delta value] [integer];
docremark [See config/prefabs.cfg for an example on usage.];
 
docident [perlin] [Generates a perlin noise landscape in the current selection.];
docargument [S] [the scale, frequency of the features] [default is 10];
docargument [E] [the random seed] [integer];
docargument [C] [cube size, how many cubes to generate a surface for at once (unused)] [];
docremark [Keep the seed the same to create multiple perlin areas which fit with eachother, or use different numbers if to create alternative random generations.];
 
docident [select] [Selects the given area, as if dragged with the mouse.];
docargument [X] [the X coordinate] [];
docargument [Y] [the Y coordinate] [];
docargument [XS] [the length along the X axis] [];
docargument [XY] [the length along the Y axis] [];
docremark [This command is useful for making complex geometry-generating scripts. The current dimensions of the selection (either created by the user or this command) are in the variables selx, sely, selxs and selys and can also be read/modified.];
docremark [Coordinates are as follows: after a "newmap 6" the top-left corner (the one where the red dot points) are (8,8), the opposite corner is (56,56) (or (120,120) on a "newmap 7" etc.).];
docref [selx] [selx] [];
docref [sely] [sely] [];
docref [selxs] [selxs] [];
docref [selys] [selys] [];
 
docident [registersound] [Registers a sound.];
docargument [N] [sound name] [string, see config/sounds.cfg];
docremark [This command returns the sound number, which is assigned from 0 onwards, and which can be used with "sound" command. If the sound was already registered, its existing index is returned. registersound does not actually load the sound, this is done on first play.];
docremark [See for example config/sounds.cfg.];
docref [sound] [sound] [];
 
docident [sound] [Plays the specified sound.];
docargument [S] [the sound to play] [string, see config/sounds.cfg];
docremark [See config/sounds.cfg for default sounds, and use registersound to register your own. For example, sound 0 and sound (registersound "aard/jump") both play the standard jump sound.];
 
docident [mapmodelreset] [Resets the mapmodel slots/indices to 0.];
docremark [Each subsequent mapmodel command increases it again. See config/default_map_settings.cfg for an example.];
 
docident [mapmodel] [Registers a mapmodel that can be placed in maps.];
docargument [R] [the square radius] [string];
docargument [H] [the height] [integer];
docargument [Z] [the initial Z-offset above ground] [integer];
docargument [S] [the snap value in 16ths of a cube unit] [integer, 0 meaning no snap];
docargument [N] [the name of the map model] [string];
docremark [A map model registered with this command can be placed in a map using the 'newent mapmodel' command. All of these values are used for collision as well as rendering. Specifying a snap can be useful for architectural mapmodels, as the md2 format doesn't provide exact vertex coordinates.];
docremark [Example: mapmodel 4 2 4 2 this map model is 8x8x2 in size (x,y,z), by default hovers 4 units above ground, and has all coordinates snapped to the nearest even number. See data/models.cfg.];
 
docident [scalelights] [Scales all lights in the map.];
docargument [P] [percentage] [integer];
docargument [I] [intensity] [integer];
docremark [This command is useful if a map is too dark or bright but you want to keep the light entities where they are.];
 
